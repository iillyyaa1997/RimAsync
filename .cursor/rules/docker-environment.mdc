# Docker Environment Requirements

## 🐳 Mandatory Docker Usage

**CRITICALLY IMPORTANT:** All compilation, testing, and build operations for the RimAsync project MUST be performed in Docker containers.

## Why Docker is Required

### ✅ Environment Consistency

- **Reproducible builds** across all development machines
- **Isolated dependencies** from host system
- **Version consistency** for .NET, RimWorld assemblies, and tools
- **Cross-platform compatibility** (macOS, Linux, Windows)

### 🔒 Safety and Isolation

- **No host contamination** - dependencies stay in containers
- **Clean test environment** - fresh state for each test run
- **Dependency conflicts avoided** - isolated package versions
- **System stability** - no interference with host system

### ⚡ Performance and Efficiency

- **Parallel execution** - multiple containers simultaneously
- **Cached layers** - faster rebuilds with Docker caching
- **Resource management** - controlled CPU/memory usage
- **Quick cleanup** - destroy containers after use

## 🔧 Mandatory Docker Commands

### Primary Commands (Use These)

#### Build and Compilation

```bash
make build              # Compile project in Docker (with colored output)
make quick-build        # Fast compilation for debugging
make clean             # Clean Docker containers and rebuild
```

#### Testing

```bash
make test              # Run all tests in Docker (with progress)
make test-unit         # Unit tests only
make test-integration  # Integration tests only
make test-performance  # Performance benchmarks
```

#### Development

```bash
make dev               # Development mode with file watching
make lint              # Code analysis and linting
make format            # Code formatting
```

### Alternative Docker Commands (If Makefile Unavailable)

```bash
docker-compose up build              # Compile project
docker-compose up test               # Run tests
docker-compose up dev                # Development mode
docker-compose up quick-build        # Quick compilation
```

## 🚫 Forbidden Local Operations

### ❌ NEVER Do These on Host System

```bash
# ❌ DON'T: Local compilation
dotnet build Source/RimAsync.sln

# ❌ DON'T: Local testing  
dotnet test Tests/

# ❌ DON'T: Local package restore
dotnet restore

# ❌ DON'T: Local code analysis
dotnet format
```

### ✅ ALWAYS Use Docker Instead

```bash
# ✅ DO: Docker compilation
make build

# ✅ DO: Docker testing
make test

# ✅ DO: Docker development
make dev
```

## 📊 Container Configuration

### Build Container (`rimasync_build`)

- **Purpose:** Project compilation and packaging
- **Base Image:** mcr.microsoft.com/dotnet/sdk:8.0
- **Target Frameworks:** .NET 4.8, .NET Standard 2.1, .NET 8.0
- **RimWorld Assemblies:** Included for compilation
- **Volume Mounts:** Source code, build outputs

### Test Container (`rimasync_test`)

- **Purpose:** Test execution and validation
- **Base Image:** mcr.microsoft.com/dotnet/sdk:8.0
- **Test Frameworks:** NUnit, BenchmarkDotNet
- **Mock Environment:** RimWorld/Verse mocks included
- **Volume Mounts:** Test results, coverage reports

### Development Container (`rimasync_dev`)

- **Purpose:** Interactive development and debugging
- **Base Image:** mcr.microsoft.com/dotnet/sdk:8.0
- **File Watching:** Automatic rebuild on changes
- **Debug Tools:** Debugging and profiling tools
- **Volume Mounts:** Live source code sync

## 🔄 Development Workflow

### Standard Development Process

1. **Start Development Environment**

   ```bash
   make dev
   ```

2. **Make Code Changes** (on host system in IDE)

3. **Automatic Rebuild** (happens in container)

4. **Run Tests**

   ```bash
   make test
   ```

5. **Build for Release**

   ```bash
   make build
   ```

### Command Integration with @execute-task

The `@execute-task` command automatically uses Docker:

```bash
User: @execute-task

AI: 🎯 Analyzing current tasks...
    📋 Selected task: "Fix compilation errors"
    
    🐳 Using Docker for all operations:
    
    1. make build          # ✅ Compilation in Docker
    2. make test           # ✅ Testing in Docker  
    3. make lint           # ✅ Code analysis in Docker
    
    🎉 Task completed successfully in Docker environment!
```

## 🐛 Troubleshooting

### Common Docker Issues

#### Container Build Fails

```bash
# Clean and rebuild
make clean
make build
```

#### Test Container Hangs

```bash
# Stop all containers
docker-compose down

# Restart with fresh containers
make test
```

#### Permission Issues (macOS/Linux)

```bash
# Fix volume permissions
docker-compose down
docker volume prune -f
make dev
```

#### Port Conflicts

```bash
# Check for conflicting processes
lsof -i :8080

# Stop conflicting services or change ports in docker-compose.yml
```

### Performance Issues

#### Slow Builds

```bash
# Use quick build for development
make quick-build

# Check Docker resources in Docker Desktop
# Increase CPU/Memory allocation if needed
```

#### Container Startup Slow

```bash
# Prune unused containers/images
docker system prune -f

# Restart Docker daemon
# macOS: Restart Docker Desktop
# Linux: sudo systemctl restart docker
```

## 📁 Volume Mounts and File Sharing

### Source Code Volumes

```yaml
volumes:
  - ./Source:/app/Source:ro          # Read-only source code
  - ./Tests:/app/Tests:ro            # Read-only test files
  - ./Build:/app/Build               # Build outputs
  - ./TestResults:/app/TestResults   # Test results
```

### File Permissions

- **Host changes** reflected immediately in containers
- **Container outputs** available on host system
- **Cross-platform compatibility** maintained

## 🔒 Security and Isolation

### Container Security

- **No privileged access** required
- **Isolated network** per container
- **Limited file system access** via volume mounts only
- **Resource limits** prevent system overload

### Host System Protection

- **No global package installation** required
- **No .NET version conflicts** with other projects
- **Clean uninstall** - just remove containers
- **Malware isolation** - contained execution environment

## ⚡ Performance Optimization

### Docker Configuration

```yaml
# docker-compose.yml optimizations
services:
  build:
    mem_limit: 4g
    cpus: '2.0'
    restart: no
```

### Build Optimization

- **Multi-stage builds** for smaller images
- **Layer caching** for faster rebuilds
- **Parallel operations** where possible
- **Minimal base images** for efficiency

### Development Optimization

```bash
# Use quick-build for rapid iteration
make quick-build

# Use specific test categories
make test-unit        # Faster than full test suite
```

## 📊 Monitoring and Logging

### Container Monitoring

```bash
# View container status
docker-compose ps

# View container logs
docker-compose logs build
docker-compose logs test

# Monitor resource usage
docker stats
```

### Build Metrics

- **Build time tracking** in container logs
- **Test execution time** with detailed reports
- **Memory usage monitoring** during operations
- **Error detection** with automated alerts

## 🎯 Best Practices

### Daily Development

1. **Always use `make` commands** for consistency
2. **Run `make clean`** if builds behave unexpectedly
3. **Check `docker-compose logs`** for debugging
4. **Monitor Docker resource usage** for performance

### CI/CD Integration

- **Same Docker configuration** used in CI/CD
- **Reproducible builds** across environments
- **Automated testing** in identical containers
- **Deployment artifacts** built in containers

---

**Remember:** Docker usage is mandatory for RimAsync development. All build, test, and development operations must use Docker containers to ensure consistency and reliability.
